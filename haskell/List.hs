import Control.Monad (forM_)

main = do
  -- リストは、同じ型の値を複数個格納できるデータ型。
  let il = [1 .. 10]
  -- リストの連結は `++` でできる。
  -- 連結する際に一つ目のリストの最後まで走査されるので、長いリストの連結時には注意が必要。
  let il = [1 .. 10] ++ [11, 12]
  -- 文字列は文字型のリストなので、文字列と文字のリストは連結できるし、文字列はリストと同じように関数で操作できる。
  let sl = "string" ++ ['!', '?']
  let rsl = reverse sl
  -- 要素へのアクセスは `!! {index}` でできる。
  let hsl = sl !! 0
  -- 要素外へのアクセスはエラーになる。
  let osl = sl !! 10
  -- リストは比較可能。要素を順に比較していく。
  print $ [1, 2] == [1, 2]
  print $ [1, 2] < [1, 10]
  -- 空のリストは空でないリストより小さい。
  print $ [] < [0]
  -- 便利な操作関数がある。以下の4つはいずれも空配列を引数にするとエラーになるので注意する。
  forM_ [head [1, 2, 3], last [1, 2, 3]] print
  forM_ [tail [1, 2, 3], init [1, 2, 3]] print
  -- null で空配列かどうか評価できる。
  sequence_ $ map print [null [], null [1]]
  -- リスト操作は色々ある。
  sequence_ $ map print [take 2 [1, 2, 3], drop 2 [1, 2, 3]]
  print $ elem 1 [1, 2, 3]
  -- レンジ `..` で列挙可能な要素のリストを作れる。
  print [1 .. 5]
  -- 最後の要素より大きくなるまで値を列挙するので `{最初の要素} > {最後の要素}` だと空配列になる。
  print [5 .. 1]
  -- 第一要素と第二要素の差をステップとして、ステップ付きレンジを作れる。
  print [3, 6 .. 3 * 10]
  -- 浮動小数点数に注意。
  print [0.1, 0.2 .. 0.5]
  -- Haskell は必要になるまで値の評価を遅延するので、無限リストを作るコードを書いたとしても、リストを使用するコードで一部を要求された文しか作られない。
  print $ head $ cycle [1, 2, 3]
  -- リスト内包表記でリスト操作ができる。
  -- `|` よりも後ろでリスト要素を束縛する処理を、`|` 要素を操作する処理を書く。
  print [x ++ "!" | x <- ["a", "b"]]
  -- さらに後ろでリストをフィルタする述語を書ける。述語の評価は要素の束縛の後に行われる。
  print [x ++ "!" | x <- ["a", "b"], 'b' `elem` x]
  -- 述語は複数書ける。AND条件になる。
  print [x ++ "!" | x <- ["a", "b_1", "b_2"], 'b' `elem` x, '2' `notElem` x]
  -- 複数のリストを束縛できる。
  print [x ++ y | x <- ["A", "B"], 'A' `elem` x, y <- ["a", "b"], 'a' `elem` y]
  -- 固定長であったり異なる要素の組み合わせが欲しい場合はタプルやトリプルを使う。
  print ("A", 1)
  print ("A", 1, True)
  -- zipは二つのリストからタプルのリストを作る。
  print $ zip [1 .. 3] ['a' .. 'c']

  print il
  print sl
  print rsl
  print hsl
